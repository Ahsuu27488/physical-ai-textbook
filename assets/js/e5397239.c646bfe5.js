"use strict";(globalThis.webpackChunkmy_website_1=globalThis.webpackChunkmy_website_1||[]).push([[3270],{8175:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"module-1/lesson-3-actions-and-launch-files","title":"Lesson 3 - Actions and Launch Files","description":"Learning Objectives","source":"@site/docs/module-1/lesson-3-actions-and-launch-files.md","sourceDirName":"module-1","slug":"/module-1/lesson-3-actions-and-launch-files","permalink":"/docs/module-1/lesson-3-actions-and-launch-files","draft":false,"unlisted":false,"editUrl":"https://github.com/Ahsuu27488/physical-ai-textbook/tree/main/frontend/docs/module-1/lesson-3-actions-and-launch-files.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Lesson 3 - Actions and Launch Files","sidebar_position":5},"sidebar":"textbookSidebar","previous":{"title":"Lesson 2 - Nodes, Topics, and Services","permalink":"/docs/module-1/lesson-2-nodes-topics-services"},"next":{"title":"Lesson 4 - URDF and Robot Description","permalink":"/docs/module-1/lesson-4-urdf-and-robot-description"}}');var t=a(4848),c=a(8453);const o={title:"Lesson 3 - Actions and Launch Files",sidebar_position:5},l="Lesson 3: Actions and Launch Files",s={},r=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"ROS 2 Actions",id:"ros-2-actions",level:2},{value:"Action Structure",id:"action-structure",level:3},{value:"Action Server",id:"action-server",level:3},{value:"Action Client",id:"action-client",level:3},{value:"Launch Files",id:"launch-files",level:2},{value:"Basic Launch File",id:"basic-launch-file",level:3},{value:"Launch File with Parameters",id:"launch-file-with-parameters",level:3},{value:"Conditional Launch",id:"conditional-launch",level:3},{value:"Practical Exercise: Navigation Action Client",id:"practical-exercise-navigation-action-client",level:2},{value:"Advanced Launch Concepts",id:"advanced-launch-concepts",level:2},{value:"Launch Substitutions",id:"launch-substitutions",level:3},{value:"Launch File Includes",id:"launch-file-includes",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"lesson-3-actions-and-launch-files",children:"Lesson 3: Actions and Launch Files"})}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this lesson, students will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Implement and use ROS 2 actions for long-running tasks"}),"\n",(0,t.jsx)(e.li,{children:"Create and configure launch files for complex systems"}),"\n",(0,t.jsx)(e.li,{children:"Understand the role of actions in robotics applications"}),"\n",(0,t.jsx)(e.li,{children:"Organize multi-node systems using launch files"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"ros-2-actions",children:"ROS 2 Actions"}),"\n",(0,t.jsx)(e.p,{children:"Actions are a communication pattern that provides feedback during long-running tasks and allows for goal preemption. They're essential for robotics tasks like navigation, manipulation, and calibration."}),"\n",(0,t.jsx)(e.h3,{id:"action-structure",children:"Action Structure"}),"\n",(0,t.jsx)(e.p,{children:"An action has three parts:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Goal"}),": The request to start the action"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Feedback"}),": Periodic updates during execution"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Result"}),": The final outcome of the action"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"action-server",children:"Action Server"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import time\nimport rclpy\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\n\nfrom example_interfaces.action import Fibonacci\n\n\nclass FibonacciActionServer(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            execute_callback=self.execute_callback,\n            callback_group=rclpy.callback_group.ReentrantCallbackGroup(),\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback)\n\n    def destroy(self):\n        self._action_server.destroy()\n        super().destroy_node()\n\n    def goal_callback(self, goal_request):\n        \"\"\"Accept or reject a client request to begin an action.\"\"\"\n        self.get_logger().info('Received goal request')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Accept or reject a client request to cancel an action.\"\"\"\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        \"\"\"Execute the goal.\"\"\"\n        self.get_logger().info('Executing goal...')\n\n        # Create messages to be sent\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return Fibonacci.Result()\n\n            # Update Fibonacci sequence\n            feedback_msg.sequence.append(\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])\n\n            # Publish feedback\n            goal_handle.publish_feedback(feedback_msg)\n            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')\n\n            # Sleep to simulate work\n            time.sleep(1)\n\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.sequence\n        self.get_logger().info(f'Result: {result.sequence}')\n\n        return result\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    fibonacci_action_server = FibonacciActionServer()\n\n    rclpy.spin(fibonacci_action_server)\n\n    fibonacci_action_server.destroy()\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h3,{id:"action-client",children:"Action Client"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import time\nimport rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\n\nfrom example_interfaces.action import Fibonacci\n\n\nclass FibonacciActionClient(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_client')\n        self._action_client = ActionClient(\n            self,\n            Fibonacci,\n            'fibonacci')\n\n    def send_goal(self, order):\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        self._action_client.wait_for_server()\n\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback)\n\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected :(')\n            return\n\n        self.get_logger().info('Goal accepted :)')\n\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        self.get_logger().info(f'Result: {result.sequence}')\n        rclpy.shutdown()\n\n    def feedback_callback(self, feedback_msg):\n        feedback = feedback_msg.feedback\n        self.get_logger().info(f'Received feedback: {feedback.sequence}')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    action_client = FibonacciActionClient()\n    action_client.send_goal(10)\n\n    rclpy.spin(action_client)\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h2,{id:"launch-files",children:"Launch Files"}),"\n",(0,t.jsx)(e.p,{children:"Launch files allow you to start multiple nodes with a single command, making it easier to manage complex robotic systems."}),"\n",(0,t.jsx)(e.h3,{id:"basic-launch-file",children:"Basic Launch File"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch_ros.actions import Node\n\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='turtlesim',\n            executable='turtlesim_node',\n            name='sim'\n        ),\n        Node(\n            package='turtlesim',\n            executable='turtle_teleop_key',\n            name='teleop'\n        )\n    ])\n"})}),"\n",(0,t.jsx)(e.h3,{id:"launch-file-with-parameters",children:"Launch File with Parameters"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\n\n\ndef generate_launch_description():\n    return LaunchDescription([\n        # Declare launch arguments\n        DeclareLaunchArgument(\n            name='frequency',\n            default_value='10.0',\n            description='Publish frequency in Hz'\n        ),\n\n        # Use launch arguments in node configuration\n        Node(\n            package='demo_nodes_py',\n            executable='talker',\n            parameters=[\n                {\n                    'frequency': LaunchConfiguration('frequency')\n                }\n            ]\n        )\n    ])\n"})}),"\n",(0,t.jsx)(e.h3,{id:"conditional-launch",children:"Conditional Launch"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IfCondition\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\n\n\ndef generate_launch_description():\n    return LaunchDescription([\n        DeclareLaunchArgument(\n            name='use_sim_time',\n            default_value='false',\n            description='Use simulation time'\n        ),\n\n        Node(\n            package='demo_nodes_py',\n            executable='listener',\n            condition=IfCondition(LaunchConfiguration('use_sim_time'))\n        )\n    ])\n"})}),"\n",(0,t.jsx)(e.h2,{id:"practical-exercise-navigation-action-client",children:"Practical Exercise: Navigation Action Client"}),"\n",(0,t.jsx)(e.p,{children:"Create an action client for navigation that sends goals to a navigation server:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"navigation_client.py:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\n\nfrom nav2_msgs.action import NavigateToPose\nfrom geometry_msgs.msg import PoseStamped\nimport math\n\n\nclass NavigationActionClient(Node):\n\n    def __init__(self):\n        super().__init__('navigation_action_client')\n        self._action_client = ActionClient(\n            self,\n            NavigateToPose,\n            'navigate_to_pose')\n\n    def send_goal(self, x, y, theta):\n        goal_msg = NavigateToPose.Goal()\n\n        # Create target pose\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.pose.position.x = x\n        goal_msg.pose.pose.position.y = y\n        goal_msg.pose.pose.orientation.z = math.sin(theta / 2.0)\n        goal_msg.pose.pose.orientation.w = math.cos(theta / 2.0)\n\n        self.get_logger().info(f'Sending navigation goal to ({x}, {y}, {theta})')\n\n        self._action_client.wait_for_server()\n\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback)\n\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Navigation goal rejected')\n            return\n\n        self.get_logger().info('Navigation goal accepted')\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        self.get_logger().info(f'Navigation completed: {result}')\n        rclpy.shutdown()\n\n    def feedback_callback(self, feedback_msg):\n        feedback = feedback_msg.feedback\n        self.get_logger().info(f'Navigating... Current pose: {feedback.current_pose}')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_client = NavigationActionClient()\n\n    # Navigate to coordinates (2.0, 2.0, 0.0)\n    action_client.send_goal(2.0, 2.0, 0.0)\n\n    rclpy.spin(action_client)\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h2,{id:"advanced-launch-concepts",children:"Advanced Launch Concepts"}),"\n",(0,t.jsx)(e.h3,{id:"launch-substitutions",children:"Launch Substitutions"}),"\n",(0,t.jsx)(e.p,{children:"Launch files support substitutions for dynamic configuration:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.substitutions import TextSubstitution, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='my_package',\n            executable='my_node',\n            parameters=[\n                PathJoinSubstitution([\n                    FindPackageShare('my_package'),\n                    'config',\n                    TextSubstitution(text='my_config.yaml')\n                ])\n            ]\n        )\n    ])\n"})}),"\n",(0,t.jsx)(e.h3,{id:"launch-file-includes",children:"Launch File Includes"}),"\n",(0,t.jsx)(e.p,{children:"You can include other launch files:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.substitutions import FindPackageShare\n\n\ndef generate_launch_description():\n    return LaunchDescription([\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource([\n                FindPackageShare('turtlebot3_bringup'),\n                '/launch/turtlebot3_world.launch.py'\n            ])\n        )\n    ])\n"})}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"This lesson covered ROS 2 actions for long-running tasks with feedback and launch files for managing complex multi-node systems. These are essential tools for building real-world robotic applications."}),"\n",(0,t.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsx)(e.p,{children:"In the next lesson, we'll explore URDF (Unified Robot Description Format) and how to describe robots in ROS 2."})]})}function d(n={}){const{wrapper:e}={...(0,c.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>o,x:()=>l});var i=a(6540);const t={},c=i.createContext(t);function o(n){const e=i.useContext(c);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),i.createElement(c.Provider,{value:e},n.children)}}}]);